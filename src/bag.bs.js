// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Map from "rescript/lib/es6/map.js";
import * as Caml from "rescript/lib/es6/caml.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Format from "rescript/lib/es6/format.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function Make(funarg) {
  var M = $$Map.Make(funarg);
  var empty = M.empty;
  var is_empty = M.is_empty;
  var mem = M.mem;
  var occ = function (x, b) {
    try {
      return Curry._2(M.find, x, b);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return 0;
      }
      throw exn;
    }
  };
  var add = function (x, multOpt, b) {
    var mult = multOpt !== undefined ? multOpt : 1;
    if (mult < 0) {
      Pervasives.invalid_arg("add");
    }
    if (mult === 0) {
      return b;
    }
    try {
      var m = Curry._2(M.find, x, b);
      return Curry._3(M.add, x, m + mult | 0, b);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return Curry._3(M.add, x, mult, b);
      }
      throw exn;
    }
  };
  var update = function (x, f, b) {
    var f$1 = function (o) {
      var m = Curry._1(f, o !== undefined ? o : 0);
      if (m < 0) {
        Pervasives.invalid_arg("update");
      }
      if (m === 0) {
        return ;
      } else {
        return m;
      }
    };
    return Curry._3(M.update, x, f$1, b);
  };
  var singleton = function (x) {
    return Curry._3(M.add, x, 1, M.empty);
  };
  var remove = function (x, multOpt, b) {
    var mult = multOpt !== undefined ? multOpt : 1;
    if (mult < 0) {
      Pervasives.invalid_arg("remove");
    }
    if (mult === 0) {
      return b;
    } else {
      return Curry._3(M.update, x, (function (m) {
                    if (m !== undefined && m !== 1 && m > mult) {
                      return m - mult | 0;
                    }
                    
                  }), b);
    }
  };
  var merge = function (f, b1, b2) {
    var f$1 = function (x, o1, o2) {
      var m1 = o1 !== undefined ? o1 : 0;
      var m2 = o2 !== undefined ? o2 : 0;
      var m = Curry._3(f, x, m1, m2);
      if (m < 0) {
        Pervasives.invalid_arg("merge");
      }
      if (m === 0) {
        return ;
      } else {
        return m;
      }
    };
    return Curry._3(M.merge, f$1, b1, b2);
  };
  var cardinal = function (b) {
    return Curry._3(M.fold, (function (param, m, c) {
                  return m + c | 0;
                }), b, 0);
  };
  var union = function (b1, b2) {
    return Curry._3(M.merge, (function (param, o1, o2) {
                  if (o1 === undefined) {
                    if (o2 !== undefined) {
                      return Caml_option.some(Caml_option.valFromOption(o2));
                    } else {
                      return ;
                    }
                  }
                  var m1 = Caml_option.valFromOption(o1);
                  if (o2 !== undefined) {
                    return Caml_option.some(Caml_obj.caml_max(m1, Caml_option.valFromOption(o2)));
                  } else {
                    return Caml_option.some(m1);
                  }
                }), b1, b2);
  };
  var sum = function (b1, b2) {
    return Curry._3(M.merge, (function (param, o1, o2) {
                  if (o1 !== undefined) {
                    if (o2 !== undefined) {
                      return o1 + o2 | 0;
                    } else {
                      return o1;
                    }
                  } else if (o2 !== undefined) {
                    return o2;
                  } else {
                    return ;
                  }
                }), b1, b2);
  };
  var inter = function (b1, b2) {
    return Curry._3(M.merge, (function (param, o1, o2) {
                  if (o1 !== undefined && o2 !== undefined) {
                    return Caml_option.some(Caml_obj.caml_min(Caml_option.valFromOption(o1), Caml_option.valFromOption(o2)));
                  }
                  
                }), b1, b2);
  };
  var diff = function (b1, b2) {
    return Curry._3(M.merge, (function (param, o1, o2) {
                  if (o1 !== undefined) {
                    if (o2 !== undefined) {
                      if (o1 <= o2) {
                        return ;
                      } else {
                        return o1 - o2 | 0;
                      }
                    } else {
                      return o1;
                    }
                  }
                  
                }), b1, b2);
  };
  var disjoint = function (b1, b2) {
    return Curry._2(M.for_all, (function (x1, param) {
                  return !Curry._2(mem, x1, b2);
                }), b1);
  };
  var included = function (b1, b2) {
    return Curry._2(M.for_all, (function (x1, m1) {
                  return m1 <= occ(x1, b2);
                }), b1);
  };
  var iter = M.iter;
  var fold = M.fold;
  var split = function (x, b) {
    var match = Curry._2(M.split, x, b);
    var m = match[1];
    return [
            match[0],
            m !== undefined ? m : 0,
            match[2]
          ];
  };
  var map = function (f) {
    return Curry._1(M.map, (function (m) {
                  var m$1 = Curry._1(f, m);
                  if (m$1 <= 0) {
                    Pervasives.invalid_arg("map");
                  }
                  return m$1;
                }));
  };
  var mapi = function (f) {
    return Curry._1(M.mapi, (function (x, m) {
                  var m$1 = Curry._2(f, x, m);
                  if (m$1 <= 0) {
                    Pervasives.invalid_arg("mapi");
                  }
                  return m$1;
                }));
  };
  var mul = function (b, n) {
    if (n < 0) {
      Pervasives.invalid_arg("mul");
    }
    if (n === 0) {
      return empty;
    } else {
      return Curry._1(map(function (m) {
                      return Math.imul(m, n);
                    }), b);
    }
  };
  var div = function (b1, b2) {
    if (Curry._1(is_empty, b2)) {
      return [
              0,
              b1
            ];
    }
    try {
      var update = function (x, m1, q) {
        var m2 = occ(x, b2);
        if (m2 === 0 || m2 > m1) {
          throw {
                RE_EXN_ID: Pervasives.Exit,
                Error: new Error()
              };
        }
        return Caml.caml_int_min(q, Caml_int32.div(m1, m2));
      };
      var q = Curry._3(fold, update, b1, Pervasives.max_int);
      if (q <= 0) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "bag.ml",
                185,
                6
              ],
              Error: new Error()
            };
      }
      var remainder = function (x, m1, r) {
        var mult = m1 - Math.imul(q, occ(x, b2)) | 0;
        return add(x, mult, r);
      };
      var r = Curry._3(fold, remainder, b1, empty);
      return [
              q,
              r
            ];
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Pervasives.Exit) {
        return [
                0,
                b1
              ];
      }
      throw exn;
    }
  };
  var divi = function (b, n) {
    if (n <= 0) {
      Pervasives.invalid_arg("divi");
    }
    var update = function (x, m, param) {
      return [
              add(x, Caml_int32.div(m, n), param[0]),
              add(x, Caml_int32.mod_(m, n), param[1])
            ];
    };
    return Curry._3(fold, update, b, [
                empty,
                empty
              ]);
  };
  var compare = Curry._1(M.compare, Caml.caml_int_compare);
  var equal = Curry._1(M.equal, (function (prim0, prim1) {
          return prim0 === prim1;
        }));
  var print = function (print_elt, fmt, b) {
    Format.fprintf(fmt, /* Format */{
          _0: {
            TAG: /* Char_literal */12,
            _0: /* '{' */123,
            _1: {
              TAG: /* Formatting_gen */18,
              _0: {
                TAG: /* Open_box */1,
                _0: /* Format */{
                  _0: /* End_of_format */0,
                  _1: ""
                }
              },
              _1: /* End_of_format */0
            }
          },
          _1: "{@["
        });
    var first = {
      contents: true
    };
    Curry._2(iter, (function (x, m) {
            if (!first.contents) {
              Format.fprintf(fmt, /* Format */{
                    _0: {
                      TAG: /* Char_literal */12,
                      _0: /* ',' */44,
                      _1: /* End_of_format */0
                    },
                    _1: ","
                  });
            }
            first.contents = false;
            return Curry._3(Format.fprintf(fmt, /* Format */{
                            _0: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Char_literal */12,
                                  _0: /* ':' */58,
                                  _1: {
                                    TAG: /* Int */4,
                                    _0: /* Int_d */0,
                                    _1: /* No_padding */0,
                                    _2: /* No_precision */0,
                                    _3: /* End_of_format */0
                                  }
                                }
                              }
                            },
                            _1: "@ %a:%d"
                          }), print_elt, x, m);
          }), b);
    if (!first.contents) {
      Format.fprintf(fmt, /* Format */{
            _0: {
              TAG: /* Char_literal */12,
              _0: /* ' ' */32,
              _1: /* End_of_format */0
            },
            _1: " "
          });
    }
    return Format.fprintf(fmt, /* Format */{
                _0: {
                  TAG: /* Formatting_lit */17,
                  _0: /* Close_box */0,
                  _1: {
                    TAG: /* Char_literal */12,
                    _0: /* '}' */125,
                    _1: /* End_of_format */0
                  }
                },
                _1: "@]}"
              });
  };
  return {
          empty: empty,
          is_empty: is_empty,
          occ: occ,
          mem: mem,
          add: add,
          update: update,
          singleton: singleton,
          remove: remove,
          remove_all: M.remove,
          merge: merge,
          cardinal: cardinal,
          elements: M.bindings,
          min_elt: M.min_binding,
          min_elt_opt: M.min_binding_opt,
          max_elt: M.max_binding,
          max_elt_opt: M.max_binding_opt,
          choose: M.choose,
          choose_opt: M.choose_opt,
          union: union,
          sum: sum,
          mul: mul,
          div: div,
          divi: divi,
          inter: inter,
          diff: diff,
          disjoint: disjoint,
          included: included,
          iter: iter,
          fold: fold,
          for_all: M.for_all,
          exists: M.exists,
          filter: M.filter,
          partition: M.partition,
          split: split,
          find_first: M.find_first,
          find_first_opt: M.find_first_opt,
          find_last: M.find_last,
          find_last_opt: M.find_last_opt,
          map: map,
          mapi: mapi,
          compare: compare,
          equal: equal,
          print: print
        };
}

export {
  Make ,
  
}
/* Format Not a pure module */
